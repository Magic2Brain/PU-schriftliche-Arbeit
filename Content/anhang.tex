\subsection{MainActivity.java}
\begin{lstlisting}
package m2b.magic2brain.com;

import android.content.Intent;
import android.content.SharedPreferences;
import android.graphics.Color;
import android.os.Bundle;
import android.preference.PreferenceManager;
import android.support.design.widget.FloatingActionButton;
import android.support.design.widget.NavigationView;
import android.support.v4.view.GravityCompat;
import android.support.v4.widget.DrawerLayout;
import android.support.v7.app.ActionBarDrawerToggle;
import android.support.v7.app.AppCompatActivity;
import android.support.v7.widget.Toolbar;
import android.view.Gravity;
import android.view.MenuItem;
import android.view.View;
import android.view.Window;
import android.view.WindowManager;
import android.widget.ImageView;
import android.widget.RelativeLayout;
import android.widget.TextView;
import com.google.gson.Gson;
import com.google.gson.reflect.TypeToken;
import com.squareup.picasso.Picasso;
import java.lang.reflect.Type;
import java.util.ArrayList;
import java.util.Arrays;
import m2b.magic2brain.com.magic2brain.R;

/*
This is where our app starts. It has a menu, shows a random card and loads some needed data.
*/

public class MainActivity extends AppCompatActivity implements NavigationView.OnNavigationItemSelectedListener {

    public static Card[] cardarray; // We will store all cards in this array. This is important for the SearchActivity. It makes the whole process alot faster.
    private ImageView imgv; // We will show the random card with this ImageView

    protected void onCreate(Bundle savedInstanceState) { // This is the very first function the app will execute at the start of the app.
        if (!checkCardArray()) { // We try to load our card-list.
            saveCardArray(); // If we don't find the card-list, we have to generate it and save it.
        }
        hideStatusBar(); // Does what is says. It hides the Statusbar
        setTheme(R.style.AppTheme_NoActionBar);  // We want to hide the ActionBar too
        super.onCreate(savedInstanceState); // This does some intern stuff. We don't need to worry about that. It's just needed.
        setContentView(R.layout.activity_main); // This adds an View to our Activity. We defined at "/res/layout/activity_main.xml" how our activity should look like.
        Toolbar toolbar = (Toolbar) findViewById(R.id.toolbar); // With this we get the Toolbar of the View.
        setSupportActionBar(toolbar); // We add the Toolbar as a SupportActionBar. If we click something on the Toolbar it will call onNavigationItemSelected();

        FloatingActionButton fab = (FloatingActionButton) findViewById(R.id.fab); // We get the "new random card"-button
        fab.setOnClickListener(new View.OnClickListener() {
            public void onClick(View view) {
                setListener(setRandomCard()); // If we click the button it should generate a new random card.
            }
        });
        // The following lines generate the drawer (Sidemenu)
        DrawerLayout drawer = (DrawerLayout) findViewById(R.id.drawer_layout);
        ActionBarDrawerToggle toggle = new ActionBarDrawerToggle(
                this, drawer, toolbar, R.string.navigation_drawer_open, R.string.navigation_drawer_close);
        drawer.setDrawerListener(toggle);
        toggle.syncState();
        NavigationView navigationView = (NavigationView) findViewById(R.id.nav_view);
        navigationView.setNavigationItemSelectedListener(this);

        Favorites.init(); // Initate Favorites

        // The following code loads the Favorites from the memory
        SharedPreferences appSharedPrefs = PreferenceManager.getDefaultSharedPreferences(this);
        Gson gson = new Gson();
        String json = appSharedPrefs.getString("favobj", null);
        Type type = new TypeToken<ArrayList<Card>>() {
        }.getType();
        ArrayList<Card> favs = gson.fromJson(json, type);
        Favorites.init();
        if (favs != null) {
            Favorites.favorites_mvid = favs;
        }
        buildNewsFeed(); // This builds the frontpage
    }

    private void hideStatusBar() { // This method simply removes the Statusbar
        requestWindowFeature(Window.FEATURE_NO_TITLE); // remove the title
        getWindow().setFlags(WindowManager.LayoutParams.FLAG_FULLSCREEN, WindowManager.LayoutParams.FLAG_FULLSCREEN); // set it to fullscreen
    }

    protected void onPause() {
        super.onPause();
        // If the user leaves our app in any way, we save all his favorites.
        SharedPreferences appSharedPrefs = PreferenceManager.getDefaultSharedPreferences(this);
        SharedPreferences.Editor prefsEditor = appSharedPrefs.edit();
        Gson gson = new Gson();
        String json = gson.toJson(Favorites.favorites_mvid);
        prefsEditor.putString("favobj", json);
        prefsEditor.commit();
    }

    public void onBackPressed() { // Closes the Drawer if we press the Back-Button on the phone
        DrawerLayout drawer = (DrawerLayout) findViewById(R.id.drawer_layout);
        if (drawer.isDrawerOpen(GravityCompat.START)) {
            drawer.closeDrawer(GravityCompat.START);
        } else {
            super.onBackPressed();
        }
    }

    public boolean onNavigationItemSelected(MenuItem item) {
        // Handle navigation view item clicks here.
        int id = item.getItemId();
        if (id == R.id.nav_search) {
            // Starts the SearchActivitiy if we click on Search
            Intent intent = new Intent(this, SearchActivity.class);
            startActivity(intent);

        } else if (id == R.id.nav_favorite) {
            // Starts the FavoritesActivity if we click ond Favorites
            Intent intent = new Intent(this, FavoritesActivity.class);
            startActivity(intent);

        } else if (id == R.id.nav_browser) {
            // Starts the BrowserActivity if we click on the Cardbrowser
            Intent intent = new Intent(this, BrowserActivity.class);
            startActivity(intent);

        } else if (id == R.id.nav_quick_learn) {
            // Starts the QueryActivity and passes the newest set (Kaladesh), if we click Quick learn
            Deck d = new Deck();
            Card[] c = DeckAssetLoader.getDeck("KLD.json",this);
            d.setSet(c);
            d.setName("Kaladesh");
            d.setCode("KLD");
            Intent i = new Intent(this, QueryActivity.class);
            i.putExtra("Set", d);
            startActivity(i);

        } else if (id == R.id.nav_history) {
            // Starts the LastSeenActivity if we click recently learned
            Intent intent = new Intent(this, LastSeenActivity.class);
            startActivity(intent);

        } else if (id == R.id.nav_share) {
            // Starts an Activity, which opens all possibilities to send the link to our app.
            Intent sendIntent = new Intent();
            sendIntent.setAction(Intent.ACTION_SEND);
            sendIntent.putExtra(Intent.EXTRA_TEXT, getString(R.string.play_store_link));
            sendIntent.setType("text/plain");
            startActivity(Intent.createChooser(sendIntent, getResources().getText(R.string.send_to)));
        }

        DrawerLayout drawer = (DrawerLayout) findViewById(R.id.drawer_layout); // We get the drawer
        drawer.closeDrawer(GravityCompat.START); // Th drawer should start closed
        return true;
    }

    public void buildNewsFeed() { // This Function generates a text and a Imageview on the screen
        int scrWidth = getWindowManager().getDefaultDisplay().getWidth(); // Get the width of the screen
        int scrHeight = getWindowManager().getDefaultDisplay().getHeight(); // Get the Height of the screen
        RelativeLayout lyt = (RelativeLayout) findViewById(R.id.main_absolute); // Get the View of the XML
        RelativeLayout.LayoutParams params; // The parameters we want to add our TextView and ImageView

        TextView score = new TextView(this); // Create new Textview
        score.setTextColor(Color.BLACK);
        score.setGravity(Gravity.CENTER);
        score.setText("Random Card");
        score.setTextSize(26);
        params = new RelativeLayout.LayoutParams(scrWidth /*Width*/, (int) (0.1 * scrHeight)/*Height*/);
        params.leftMargin = 0; // X-Position
        params.topMargin = (int) (0.1 * scrHeight); // Y-Position
        lyt.addView(score, params); // add it to the View

        imgv = new ImageView(this); // Create new Imageview
        params = new RelativeLayout.LayoutParams(scrWidth /*Width*/, (int) (0.6 * scrHeight))/*Height*/;
        params.leftMargin = 0; // X-Position
        params.topMargin = (int) (0.2 * scrHeight); // Y-Position
        lyt.addView(imgv, params); // add it to the View
        setListener(setRandomCard()); // Opens a random card
    }

    public void setListener(int MultiID2) { // This function sets an listener to the image, so if we click it, it shows a big image of the card.
        final int MultiID = MultiID2;
        imgv.setOnClickListener(new View.OnClickListener() {
            public void onClick(View view) {
                Intent intent = new Intent(MainActivity.this, CardImageDisplayActivity.class);
                intent.putExtra("pic", MultiID);
                startActivity(intent);
            }
        });
    }

    public int setRandomCard() { // This gets a random card from the card-array and loads the image into the ImageView
        int MultiID = 1;
        Card c = cardarray[(int) (Math.random() * cardarray.length)];
        if (c != null) {
            MultiID = c.getMultiverseid();
        }
        Picasso.with(this)
                .load(getString(R.string.image_link_1) + MultiID +  getString(R.string.image_link_2)) // This tries to load an image from a link.
                .placeholder(R.drawable.loading_image) // We want to show a image while its loading. We load our image from the "/res/drawable" folder
                .error(R.drawable.image_not_found)  // If it fails to load image we show an error-image.
                .into(imgv);  // This places the image into our ImageView.
        return MultiID;
    }

    public boolean checkCardArray() { // This method checks if there is a saved version of our card array. If that's the case it tries to load it into the card-array.
        SharedPreferences sharedPrefs = PreferenceManager.getDefaultSharedPreferences(this);
        Gson gson = new Gson();
        String json = sharedPrefs.getString("cardArray", null);
        Type type = new TypeToken<Card[]>() {
        }.getType();
        Card[] aL = gson.fromJson(json, type);
        if (aL == null) {return false;}
        cardarray = aL;
        return true;
    }

    public void saveCardArray() { // This function saves the card-array into the memory.
        Card[] c = buildCardArray();
        SharedPreferences sharedPrefs = PreferenceManager.getDefaultSharedPreferences(this);
        SharedPreferences.Editor editor = sharedPrefs.edit();
        Gson gson = new Gson();
        String json = gson.toJson(c);
        editor.putString("cardArray", json);
        editor.commit();
        cardarray = c;
    }

    private Card[] buildCardArray() { // This method generates the card-array by opening all sets and loading the cards from it into out array.
        ArrayList<Card> list = new ArrayList<>();
        Deck[] deckarray = DeckAssetLoader.getDeckList(this);
        for (int i = 0; i < deckarray.length; i++) {
            //load current deck and append it to list
            Card[] c = DeckAssetLoader.getDeck(deckarray[i].getCode() + ".json", this);
            if (c[0].getName().equals("error")) {
                System.err.println("error ocurred at " + deckarray[i].getCode() + ", please update your database");
            } else {
                list.addAll(Arrays.asList(c));
            }
        }
        return list.toArray(new Card[list.size()]);
    }
}
\end{lstlisting}
\newpage
\subsection{SearchActivity.java}
\begin{lstlisting}
package m2b.magic2brain.com;

import android.content.Context;
import android.content.Intent;
import android.os.Bundle;
import android.support.v7.app.AppCompatActivity;
import android.view.MenuItem;
import android.view.View;
import android.view.View.OnClickListener;
import android.widget.Button;
import m2b.magic2brain.com.magic2brain.R;

/*
This Activity asks the user if he wants to search for cards or set and opens a SearchHandlerActivity if the answer.
*/

public class SearchActivity extends AppCompatActivity {

    protected void onCreate(Bundle savedInstanceState) {
        overridePendingTransition(R.anim.slide_in_left, R.anim.slide_out_left); // This adds an fancy slide animation, when this activity starts.
        super.onCreate(savedInstanceState); // This does some intern stuff. We don't need to worry about that. It's just needed.
        setContentView(R.layout.activity_search); // This adds an View to our Activity. We defined at "/res/layout/activity_search.xml" how our activity should look like.
        getSupportActionBar().setDisplayHomeAsUpEnabled(true); // With this line we add an "back"-Button to the Toolbar. If we press it it calls onOptionsItemSelected();
        final Context context = this; // This doesn't actually do anything, but it's needed if we want to refer to "this" from an inner class.
        setTitle(getString(R.string.SearchActivity_title)); // We set a title to our View. We defined the title in "/res/values/strings.xml". We just load it from there.
        Button cards = (Button) findViewById(R.id.c_search_cards); // We get the cards-button
        Button decks = (Button) findViewById(R.id.c_search_decks); // We get the sets-button

        cards.setOnClickListener(new OnClickListener() {
            public void onClick(View view) {
                // If the user presses the cards-button, we start SearchHandlerActivity and pass to it, that the user pressed "cards"
                Intent intent = new Intent(context, SearchHandlerActivity.class);
                intent.putExtra("cardsearch", true);
                startActivity(intent);
            }
        });

        decks.setOnClickListener(new OnClickListener() {
            public void onClick(View view) {
                // If the user presses the sets-button, we start SearchHandlerActivity and pass to it, that the user pressed "sets"
                Intent intent = new Intent(context, SearchHandlerActivity.class);
                intent.putExtra("cardsearch", false);
                startActivity(intent);
            }
        });
    }

    public boolean onOptionsItemSelected(MenuItem item) {
        switch (item.getItemId()) {
            // Respond to the action bar's Up/Home button
            case android.R.id.home:
                onBackPressed();
        }
        return true;
    }

    public void onBackPressed() {
        finish(); // This closes our Activity
        overridePendingTransition(R.anim.slide_in_right, R.anim.slide_out_right); // We want to close it with an fancy animation.
    }
}

\end{lstlisting}
\newpage
\subsection{SearchHandlerActivity.java}
\begin{lstlisting}
package m2b.magic2brain.com;

import android.content.Context;
import android.content.Intent;
import android.os.Bundle;
import android.support.v7.app.AppCompatActivity;
import android.text.Editable;
import android.text.TextWatcher;
import android.view.MenuItem;
import android.view.View;
import android.widget.AdapterView;
import android.widget.ArrayAdapter;
import android.widget.EditText;
import android.widget.ListView;
import m2b.magic2brain.com.magic2brain.R;

/*
This Activity is the one that actually searches for cards/sets.
*/

public class SearchHandlerActivity extends AppCompatActivity {
    Card[] cardarray; // This is the array, where all cards are stored

    protected void onCreate(Bundle savedInstanceState) {
        overridePendingTransition(R.anim.slide_in_left, R.anim.slide_out_left); // This adds an fancy slide animation, when this activity starts.
        super.onCreate(savedInstanceState);  // This does some intern stuff. We don't need to worry about that. It's just needed.
        setContentView(R.layout.activity_search_handler); // This adds an View to our Activity. We defined at "/res/layout/activity_search_handler.xml" how our activity should look like.
        getSupportActionBar().setDisplayHomeAsUpEnabled(true); // With this line we add an "back"-Button to the Toolbar. If we press it it calls onOptionsItemSelected();

        final Context context = this; // This doesn't actually do anything, but it's needed if we want to refer to "this" from an inner class.
        Intent inte = getIntent();  // We want to access any data that is passed.
        final Boolean cardsearch = inte.getBooleanExtra("cardsearch", true); // We look if the user wants to search for a card or set

        final EditText search_field = (EditText) findViewById(R.id.search_text); // We get the search-field
        if (cardsearch) {
            search_field.setHint(R.string.SearchHandler_hint_1); // if he wants to search a card, we set the hint to "Cardname"
        } else {
            search_field.setHint(R.string.SearchHandler_hint_2); // if he wants to search a set, we set the hint to "Setname"
        }
        final ListView searchresultsview = (ListView) findViewById(R.id.search_lv); // We get the ListView so we can show the results

        String[] names = new String[1]; // We only need the names so we create a names-array
        names[0] = getString(R.string.error); // This is to ensure that the array isn't empty
        Deck[] deckarray = DeckAssetLoader.getDeckList(this); // We get all decks


        if (cardsearch) {
            cardarray = MainActivity.cardarray; // We load our card-array
            names = new String[cardarray.length];

            for (int i = 0; i < cardarray.length; i++) {
                names[i] = cardarray[i].getName(); // And add all names to the string-array
            }
        } else {
            names = new String[deckarray.length]; // The same like cards but with sets

            for (int i = 0; i < deckarray.length; i++) {
                names[i] = deckarray[i].getName();  // The same like cards but with sets
            }
        }

        //finalizing variables for further use
        final Deck[] cdeckarray = deckarray;
        final Card[] ccardarray = cardarray;


        final ArrayAdapter adapter = new ArrayAdapter(context, android.R.layout.simple_list_item_1, names); // We turn the string-array into a list
        search_field.addTextChangedListener(new TextWatcher() { // and add a listener, so it updates when we write something
            public void beforeTextChanged(CharSequence charSequence, int i, int i1, int i2) {}
            public void onTextChanged(CharSequence charSequence, int i, int i1, int i2) {}
            public void afterTextChanged(Editable editable) {
                adapter.getFilter().filter(editable.toString().toLowerCase());
            }
        });

        searchresultsview.setAdapter(adapter); // We show the list
        searchresultsview.setOnItemClickListener(new AdapterView.OnItemClickListener() {
            public void onItemClick(AdapterView<?> parent, View view, int position, long id) {
                if (cardsearch) {
                    // If it's a card-search, we open CardBrowserActivity with the clicked card.
                    String cardname = adapter.getItem(position).toString();
                    Intent intent = new Intent(context, CardBrowserActivity.class);
                    intent.putExtra("currentCard", searchforcard(cardname, ccardarray));
                    startActivity(intent);
                } else {
                    // If it's a set-search, we open DeckDisplayActivity with the clicked Set
                    String deckname = adapter.getItem(position).toString();
                    Intent intent = new Intent(context, DeckDisplayActivity.class);
                    intent.putExtra("code", searchfordeck(deckname, cdeckarray));
                    intent.putExtra("name", deckname);
                    startActivity(intent);
                }
            }
        });

    }

    private Card searchforcard(String name, Card[] cardarray) { // This function searchs for a card and returns it
        Card rc = new Card();

        for (int i = 0; i < cardarray.length; i++) {
            if (cardarray[i].getName().equals(name)) {
                rc = cardarray[i];
                break;
            }
        }
        return rc;
    }

    private String searchfordeck(String name, Deck[] darray) { // This function searchs for a set and returns it
        String code = getString(R.string.error);

        for (int i = 0; i < darray.length; i++) {
            String dname = darray[i].getName();

            if (dname.equals(name)) {
                code = darray[i].getCode();
                break;
            }
        }

        return code;
    }

    public boolean onOptionsItemSelected(MenuItem item) {
        int id = item.getItemId();
        switch (id) {
            // Respond to the action bar's Up/Home button
            case android.R.id.home:
                onBackPressed();
        }
        return true;
    }

    public void onBackPressed() {
        finish(); // This closes our Activity
        overridePendingTransition(R.anim.slide_in_right, R.anim.slide_out_right); // We want to close it with an fancy animation.
    }
}

\end{lstlisting}
\newpage
\subsection{BrowserActivity.java}
\begin{lstlisting}
package m2b.magic2brain.com;

import android.content.Context;
import android.content.Intent;
import android.os.Bundle;
import android.support.v7.app.AppCompatActivity;
import android.support.v7.widget.Toolbar;
import android.view.MenuItem;
import android.view.View;
import android.widget.AdapterView;
import android.widget.AdapterView.OnItemClickListener;
import android.widget.ArrayAdapter;
import android.widget.ListView;
import m2b.magic2brain.com.magic2brain.R;

/*
This Activity should show a List with all sets and open DeckDisplayActivity with the selected set on a click.
*/

public class BrowserActivity extends AppCompatActivity {

    protected void onCreate(Bundle savedInstanceState) {
        overridePendingTransition(R.anim.slide_in_left, R.anim.slide_out_left); // This adds an fancy slide animation, when this activity starts.
        super.onCreate(savedInstanceState); // This does some intern stuff. We don't need to worry about that. It's just needed.
        setContentView(R.layout.activity_browser); // This adds an View to our Activity. We defined at "/res/layout/activity_browser.xml" how our activity should look like.
        Toolbar toolbar = (Toolbar) findViewById(R.id.toolbar); // With this we get the Toolbar of the View.
        setSupportActionBar(toolbar); // We add the Toolbar as a SupportActionBar. This is needed for the next line.
        getSupportActionBar().setDisplayHomeAsUpEnabled(true); // With this line we add an "back"-Button to the Toolbar. If we press it it calls onOptionsItemSelected();
        setTitle(getString(R.string.BrowserActivity_title)); // We set a title to our View. We defined the title in "/res/values/strings.xml". We just load it from there.
        final Context currentContext = this; // This doesn't actually do anything, but it's needed if we want to refer to "this" from an inner class.

        Deck d[] = DeckAssetLoader.getDeckList(this); // We load all Sets with our own function into an Deck-Array.
        String[] it = new String[d.length]; // We just need the names of the sets. So we create an String-Array for the names.
        for (int i = 0; i < d.length; i++) {
            it[i] = d[i].getName();  // This for-loop adds the names from every Deck from the Deck-Array to the String-Array.
        }

        final String[] listItems = it; // We need to finalize the String-Array for the ArrayAdapter.
        final Deck[] finalD = d; // We need to finalize the Deck-Array, because we want to access it from an inner class.
        final ArrayAdapter adapter = new ArrayAdapter(this, android.R.layout.simple_list_item_1, listItems); // This is just a helper-class. It transforms our String-Array into an clickable List.
        ListView lv = (ListView) findViewById(R.id.deckbrowser_list); // We want to add our list to the ListView. So we get the ListView from the View
        lv.setAdapter(adapter); // We add our list into it.


        lv.setOnItemClickListener(new OnItemClickListener() { // This performs an action when we click on an item from the list.
            public void onItemClick(AdapterView<?> parent, View view, int position, long id) {
                // The following code starts DeckDisplayActivity and passes the Deck-Code and the Deck-Name of the item we clicked.
                Intent intent = new Intent(currentContext, DeckDisplayActivity.class);
                intent.putExtra("code", finalD[position].getCode());
                intent.putExtra("name", finalD[position].getName());
                startActivity(intent);
            }
        });
    }

    public boolean onOptionsItemSelected(MenuItem item) {
        switch (item.getItemId()) {
            // Respond to the action bar's Up/Home button
            case android.R.id.home:
                onBackPressed();
        }
        return true;
    }

    public void onBackPressed() {
        finish(); // This closes our Activity
        overridePendingTransition(R.anim.slide_in_right, R.anim.slide_out_right); // We want to close it with an fancy animation.
    }

}
\end{lstlisting}
\newpage
\subsection{DeckDisplayActivity.java}
\begin{lstlisting}
package m2b.magic2brain.com;

import android.content.Context;
import android.content.DialogInterface;
import android.content.Intent;
import android.os.Bundle;
import android.support.design.widget.FloatingActionButton;
import android.support.v7.app.AlertDialog;
import android.support.v7.app.AppCompatActivity;
import android.view.MenuItem;
import android.view.View;
import android.widget.AdapterView;
import android.widget.AdapterView.OnItemClickListener;
import android.widget.ArrayAdapter;
import android.widget.ListView;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import m2b.magic2brain.com.magic2brain.R;

/*
This class shows all cards of a deck in a list
 */
public class DeckDisplayActivity extends AppCompatActivity {

    protected void onCreate(Bundle savedInstanceState) {
        overridePendingTransition(R.anim.slide_in_left, R.anim.slide_out_left); // This adds an fancy slide animation, when this activity starts.
        super.onCreate(savedInstanceState); // This does some intern stuff. We don't need to worry about that. It's just needed.
        setContentView(R.layout.activity_deck_display); // This adds an View to our Activity. We defined at "/res/layout/activity_deck_display.xml" how our activity should look like.
        getSupportActionBar().setDisplayHomeAsUpEnabled(true); // With this line we add an "back"-Button to the Toolbar. If we press it it calls onOptionsItemSelected();

        final Context currentContext = this; // This doesn't actually do anything, but it's needed if we want to refer to "this" from an inner class.
        Intent intent = getIntent(); // We want to access any data that is passed.
        final String deckcode = intent.getStringExtra("code"); // we get the deck-code
        final String name = intent.getStringExtra("name"); // we get the deck-name

        setTitle(name); // We set the title of the activity to the name of the deck
        Card c[] = DeckAssetLoader.getDeck(deckcode + ".json", this); // This gets all the cards from the deck
        final Card[] cCopy = c; // and adds it to an Array

        FloatingActionButton fam = (FloatingActionButton) findViewById(R.id.fab_setlearn); // This gets the "Learn"-Button
        fam.setOnClickListener(new View.OnClickListener() { // and adds a listener to it
            public void onClick(View view) {
                // The following code starts the QueryActivity and passes the deck
                Intent intent = new Intent(currentContext, QueryActivity.class);
                Deck d = new Deck();
                List<Card> clist = Arrays.asList(cCopy);
                d.setCode(deckcode);
                d.setName(name);
                d.setSet(new ArrayList<Card>(clist));
                intent.putExtra("Set", d);
                startActivity(intent);
            }
        });

        ListView lv = (ListView) findViewById(R.id.deckdisplay); // We get the Listview

        if (c[0] == null) { // If there are no cards in the deck, we show an error message
            AlertDialog.Builder dlgAlert = new AlertDialog.Builder(this);
            dlgAlert.setMessage("Sadly, this Deck was not Found");
            dlgAlert.setTitle("Error");
            dlgAlert.setPositiveButton("I understand, bill me your server costs",
                    new DialogInterface.OnClickListener() {
                        public void onClick(DialogInterface dialog, int which) {
                            //dismiss the dialog
                            onBackPressed();
                        }
                    });
            dlgAlert.setCancelable(true);
            dlgAlert.create().show();

            lv.setVisibility(View.GONE);
            fam.setVisibility(View.GONE);
        } else { // If there are some cards in the deck, we generate a card-list like we did in various other Activities
            final String[] listItems = RUtils.getListified(c);
            final ArrayAdapter adapter = new ArrayAdapter(this, android.R.layout.simple_list_item_1, listItems);
            lv.setAdapter(adapter);

            final Card[] finalC = c;

            lv.setOnItemClickListener(new OnItemClickListener() {
                public void onItemClick(AdapterView<?> parent, View view, int position, long id) {
                    Intent intent = new Intent(currentContext, CardBrowserActivity.class);
                    intent.putExtra("currentCard", finalC[position]);
                    startActivity(intent);
                }
            });
        }
    }

    public boolean onOptionsItemSelected(MenuItem item) {
        int id = item.getItemId();
        switch (id) {
            // Respond to the action bar's Up/Home button
            case android.R.id.home:
            onBackPressed();
        }
        return true;
    }

    public void onBackPressed() {
        finish(); // This closes our Activity
        overridePendingTransition(R.anim.slide_in_right, R.anim.slide_out_right); // We want to close it with an fancy animation.
    }
}
\end{lstlisting}
\newpage
\subsection{CardBrowserActivity.java}
\begin{lstlisting}
package m2b.magic2brain.com;

import android.content.Context;
import android.content.Intent;
import android.graphics.Color;
import android.os.Bundle;
import android.support.design.widget.FloatingActionButton;
import android.support.design.widget.Snackbar;
import android.support.v7.app.AppCompatActivity;
import android.support.v7.widget.Toolbar;
import android.util.TypedValue;
import android.view.Gravity;
import android.view.View;
import android.widget.ImageView;
import android.widget.LinearLayout;
import android.widget.TextView;
import com.squareup.picasso.Picasso;
import java.util.ArrayList;
import java.util.Arrays;
import m2b.magic2brain.com.magic2brain.R;

/*
This activity should show one card with all informations
*/
public class CardBrowserActivity extends AppCompatActivity {

    ImageView cImage; // We will store our ImageView in a global variable, because we want to acces it from various methods.

    protected void onCreate(final Bundle savedInstanceState) {
        overridePendingTransition(R.anim.slide_in_left, R.anim.slide_out_left); // This adds an fancy slide animation, when this activity starts.
        final Context context = this; // This doesn't actually do anything, but it's needed if we want to refer to "this" from an inner class.
        super.onCreate(savedInstanceState); // This does some intern stuff. We don't need to worry about that. It's just needed.

        Intent mIntent = getIntent(); // We want to access any data that is passed.
        final Card card = (Card) mIntent.getSerializableExtra("currentCard"); // We load the card-object from the Intent

        setContentView(R.layout.activity_card_browser);  // This adds an View to our Activity. We defined at "/res/layout/activity_card_browser.xml" how our activity should look like.
        Toolbar toolbar = (Toolbar) findViewById(R.id.toolbar); // With this we get the Toolbar of the View.
        toolbar.setTitle(card.getName()); // We set a title to our View. The title should be the name of the card.
        setSupportActionBar(toolbar); // We add the Toolbar as a SupportActionBar.

        cImage = (ImageView) findViewById(R.id.cbaImage); // We load our ImageView from the View
        cImage.setPadding(0, 10, 0, 10); // We add a padding to it.

        // The next couple lines builds a GUI with the informations from the card. We access all Views from our View.
        TextView tv = (TextView) findViewById(R.id.cbaInfo);
        String info = "";
        info += " Name: " + card.getName();
        info += "\n MVID: " + card.getMultiverseid();
        tv.setText(info);
        tv.setTextColor(Color.BLACK);
        tv.setPadding(0, 10, 0, 10);

        TextView text = (TextView) findViewById(R.id.cbaText);
        text.setText(card.getText());
        text.setTextColor(Color.BLACK);
        text.setPadding(20, 10, 10, 20);

        TextView flavor = (TextView) findViewById(R.id.cbaFlavor);
        flavor.setText(card.getFlavor());
        flavor.setTextColor(Color.BLACK);
        flavor.setPadding(20, 10, 10, 20);

        TextView type = (TextView) findViewById(R.id.cbaType);
        type.setText(card.getType());
        type.setTextColor(Color.BLACK);
        type.setPadding(0, 10, 0, 10);

        LinearLayout ll = (LinearLayout) findViewById(R.id.cba_mcost_layout);
        setManaCost(card.getManaCost(), ll);
        ll.setGravity(Gravity.CENTER);
        ll.setPadding(0, 10, 0, 10);

        final int mvid = card.getMultiverseid(); // This gets the MultiverseID from the card
        showPic(mvid); // and loads the picture of the card.

        cImage.setOnClickListener(new View.OnClickListener() {  // This performs an action if we click the image
            public void onClick(View view) {
                // The following code starts the CardImageDisplayActivity and passes the MultiverseID of the Card.
                Intent intent = new Intent(context, CardImageDisplayActivity.class);
                intent.putExtra("pic", mvid);
                startActivity(intent);
            }
        });

        final FloatingActionButton fab = (FloatingActionButton) findViewById(R.id.fab); // This gets our "add to favorites"-button from the view
        // We check if its already added to favorites. If so we mark it as already added.
        if (!checkCard(card.getName())) {
            fab.setImageResource(R.drawable.ic_favorite_border);
        } else {
            fab.setImageResource(R.drawable.ic_favorite);
        }

        fab.setOnClickListener(new View.OnClickListener() { // This performs an action if we click the "add to favorites"-Button
            // The following code toggles the Button, so it shows that the card was added or not, gives a notification and add the card to the favorites-list (which will be saved).
            public void onClick(View view) {
                if (checkCard(card.getName())) {
                    removeCard(card.getName());
                    fab.setImageResource(R.drawable.ic_favorite_border);
                    Snackbar.make(view, R.string.remove_fav, Snackbar.LENGTH_LONG)
                            .setAction("Action", null).show();
                } else {
                    Favorites.favorites_mvid.add(card);
                    fab.setImageResource(R.drawable.ic_favorite);
                    Snackbar.make(view, R.string.add_fav, Snackbar.LENGTH_LONG)
                            .setAction("Action", null).show();
                }
            }
        });
    }

    private boolean checkCard(String name) { // This function checks if the card was added to the favorites
        for (Card c : Favorites.favorites_mvid) {
            if (c.getName().contains(name)) {
                return true;
            }
        }
        return false;
    }

    private void removeCard(String name) { // This function removes the card from the favorites-list
        ArrayList<Card> cards = new ArrayList<>();
        for (Card c : Favorites.favorites_mvid) {
            if (c.getName().contains(name)) {
                cards.add(c);
            }
        }
        for (Card c : cards) {
            Favorites.favorites_mvid.remove(c);
        }
    }

    private void setManaCost(String manatext, LinearLayout layout) { // This function adds the mana-cost to the View by loading the images.
        manatext = manatext.replaceAll("\\{", "");
        manatext = manatext.replaceAll("\\}", "");
        String[] items = manatext.split("");
        items = Arrays.copyOfRange(items, 1, items.length);

        for (int i = 0; i < items.length; i++) {
            if (RUtils.isInteger(items[i])) {
                TextView tv = new TextView(this);
                tv.setText(items[i]);
                tv.setTextSize(TypedValue.COMPLEX_UNIT_PX, 80);
                tv.setTextColor(Color.BLACK);
                layout.addView(tv);
            } else {
                ImageView imgv = new ImageView(this);
                int resid = 0;
                if (items[i].equals("B")) {
                    resid = R.drawable.b;
                } else if (items[i].equals("C")) {
                    resid = R.drawable.c;
                } else if (items[i].equals("G")) {
                    resid = R.drawable.g;
                } else if (items[i].equals("R")) {
                    resid = R.drawable.r;
                } else if (items[i].equals("U")) {
                    resid = R.drawable.u;
                } else if (items[i].equals("W")) {
                    resid = R.drawable.w;
                } else {
                    resid = R.drawable.ic_action_cancel;
                }
                imgv.setBackgroundResource(resid);
                layout.addView(imgv);
                android.view.ViewGroup.LayoutParams layoutParams = imgv.getLayoutParams();
                layoutParams.width = 60;
                layoutParams.height = 60;
                imgv.setLayoutParams(layoutParams);
            }
        }
    }

    private void showPic(int MultiID) { // This method loads an cardimage into cImage with a given MultiverseID.
        Picasso.with(this)
                .load(getString(R.string.image_link_1) + MultiID + getString(R.string.image_link_2)) // This tries to load an image from a link.
                .placeholder(R.drawable.loading_image) // We want to show a image while its loading. We load our image from the "/res/drawable" folder
                .error(R.drawable.image_not_found) // If it fails to load image we show an error-image.
                .into(cImage); // This places the image into our ImageView.
    }

    public void onBackPressed() {
        finish(); // This closes our Activity
        overridePendingTransition(R.anim.slide_in_right, R.anim.slide_out_right); // We want to close it with an fancy animation.
    }
}
\end{lstlisting}
\newpage
\subsection{CardImageDisplayActivity.java}
\begin{lstlisting}
package m2b.magic2brain.com;

import android.content.Intent;
import android.os.Bundle;
import android.os.Handler;
import android.support.v7.app.ActionBar;
import android.support.v7.app.AppCompatActivity;
import android.view.View;
import android.widget.ImageView;
import com.squareup.picasso.Picasso;
import m2b.magic2brain.com.magic2brain.R;

/*
This Activity should show a big image of a card
 */

public class CardImageDisplayActivity extends AppCompatActivity {
    private final Handler mHideHandler = new Handler();
    private View mContentView;
    private final Runnable mHidePart2Runnable = new Runnable() {
        public void run() {
            // Delayed removal of status and navigation bar
            // Note that some of these constants are new as of API 16 (Jelly Bean)
            // and API 19 (KitKat). It is safe to use them, as they are inlined
            // at compile-time and do nothing on earlier devices.
            mContentView.setSystemUiVisibility(View.SYSTEM_UI_FLAG_LOW_PROFILE
                    | View.SYSTEM_UI_FLAG_FULLSCREEN
                    | View.SYSTEM_UI_FLAG_LAYOUT_STABLE
                    | View.SYSTEM_UI_FLAG_IMMERSIVE_STICKY
                    | View.SYSTEM_UI_FLAG_LAYOUT_HIDE_NAVIGATION
                    | View.SYSTEM_UI_FLAG_HIDE_NAVIGATION);
        }
    };
    private View mControlsView;
    private final Runnable mShowPart2Runnable = new Runnable() {
        @Override
        public void run() {
            // Delayed display of UI elements
            ActionBar actionBar = getSupportActionBar();
            if (actionBar != null) {
                actionBar.show();
            }
            mControlsView.setVisibility(View.VISIBLE);
        }
    };

    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_card_image_display);

        mControlsView = findViewById(R.id.fullscreen_content_controls);
        mContentView = findViewById(R.id.fullscreen_content);
        Intent mIntent = getIntent();

        // Set up the user interaction to manually show or hide the system UI.
        mContentView.setOnClickListener(new View.OnClickListener() {
            public void onClick(View view) {
                finish();
            }
        });

        // Upon interacting with UI controls, delay any scheduled hide()
        // operations to prevent the jarring behavior of controls going away
        // while interacting with the UI.
        hide();

        int mvid = mIntent.getIntExtra("pic", 0);
        showPic(mvid);
    }

    private void showPic(int MultiID) {
        ImageView cImage = (ImageView) findViewById(R.id.cida_imgview);
        Picasso.with(this)
                .load(getString(R.string.image_link_1) + MultiID + getString(R.string.image_link_2))
                .placeholder(R.drawable.loading_image)
                .error(R.drawable.image_not_found)
                .into(cImage);
    }

    private void hide() {
        // Hide UI first
        ActionBar actionBar = getSupportActionBar();
        if (actionBar != null) {
            actionBar.hide();
        }
        mControlsView.setVisibility(View.GONE);
        // Schedule a runnable to remove the status and navigation bar after a delay
        mHideHandler.removeCallbacks(mShowPart2Runnable);
        mHidePart2Runnable.run();
    }
}
\end{lstlisting}
\newpage
\subsection{QueryActivity.java}
\begin{lstlisting}
package m2b.magic2brain.com;

import android.content.Intent;
import android.content.SharedPreferences;
import android.graphics.Color;
import android.graphics.PorterDuff;
import android.os.Bundle;
import android.os.Handler;
import android.preference.PreferenceManager;
import android.support.v7.app.AppCompatActivity;
import android.support.v7.widget.Toolbar;
import android.view.Gravity;
import android.view.KeyEvent;
import android.view.Menu;
import android.view.MenuItem;
import android.view.View;
import android.view.WindowManager;
import android.view.animation.AccelerateInterpolator;
import android.view.animation.Animation;
import android.view.animation.AnimationUtils;
import android.view.animation.DecelerateInterpolator;
import android.widget.Button;
import android.widget.EditText;
import android.widget.ImageView;
import android.widget.RelativeLayout;
import android.widget.TextView;
import com.google.gson.Gson;
import com.google.gson.reflect.TypeToken;
import com.squareup.picasso.Picasso;
import java.lang.reflect.Type;
import java.util.ArrayList;
import java.util.Collections;
import java.util.Random;
import m2b.magic2brain.com.magic2brain.R;

public class QueryActivity extends AppCompatActivity {
    private ImageView imgv; // The image of the card gets stored here
    private ImageView imgCorr; // Is over the image. It's to indicate if the answer was correct or not
    private Toolbar hiding; // This is a bar that hides a certain area
    private ArrayList<Card> set; //This Arraylist holds all Cards that need to query. It won't be edited (after loading it)
    private ArrayList<Card> wrongGuessed;
    private int indexCard; // Actually not needed (because we remove cards from WrongGuessed) but may be useful in later edits
    private boolean firstGuess; //This is to check if he guessed it at first try. If so we remove the card from the Arraylist. Else it stays there.
    private String deckName; //Name of the deck. Only for saving/loading purpose
    private TextView score; //this will show the user the current progress
    private boolean queryLand = true; // should we really query lands?
    private boolean skipped = false; // this is to store if the user has skipped or not
    private ArrayList<String> recentlyLearned; // this is to save the deckname if a new set is learned
    private ArrayList<String> recentlyLearnedNames; // the name of the sets
    private int Mode; // the query mode
    private ArrayList<Button> choices; // We store the buttons here

    protected void onCreate(Bundle savedInstanceState) {
        // Standard stuff
        overridePendingTransition(R.anim.slide_in_left, R.anim.slide_out_left); // This adds an fancy slide animation, when this activity starts.
        super.onCreate(savedInstanceState); // This does some intern stuff. We don't need to worry about that. It's just needed.
        setContentView(R.layout.activity_query); // This adds an View to our Activity. We defined at "/res/layout/activity_query.xml" how our activity should look like.
        // Hide the status bar.
        this.getWindow().setFlags(WindowManager.LayoutParams.FLAG_FULLSCREEN, WindowManager.LayoutParams.FLAG_FULLSCREEN);
        // Get some informations
        Intent i = getIntent();
        Deck qur = (Deck) i.getSerializableExtra("Set");
        deckName = qur.getName(); // Get the name of the Deck
        String code = qur.getCode(); // Get the Deck-Code
        if (deckName == null) {
            deckName = "DEFAULT"; // If deckname isn't defined, we set it to "DEFAULT"
        }
        setTitle(deckName); // we set the title to the deckname
        //Add set to recent learned
        if (!loadRecent()) {
            recentlyLearned = new ArrayList<>();
            recentlyLearnedNames = new ArrayList<>();
        }
        if (!recentlyLearned.contains(code)) {
            recentlyLearned.add(code);
            recentlyLearnedNames.add(deckName);
        }
        if (recentlyLearned.size() == 10) {
            recentlyLearned.remove(0);
            recentlyLearnedNames.remove(0);
        }
        saveRecent();
        //load set
        set = qur.getSet();
        if (!loadProgress()) { //First we try to load the progress. If this fails, we simply start over
            wrongGuessed = (ArrayList) set.clone(); //Lets assume he guessed everything wrong and remove the card of this Array when he guesses it right
            shuffleWrongs(); //Shuffle it a bit (better learn-effect)
            indexCard = 0; // We start at card No. 1
        }
        //Set Mode
        Mode = 1;
        if (set.size() < 4) {
            Mode = 0;
        }
        // Build UI
        hiding = (Toolbar) findViewById(R.id.toolbar_query);
        getSupportActionBar().setDisplayHomeAsUpEnabled(true); // With this line we add an "back"-Button to the Toolbar. If we press it it calls onOptionsItemSelected();
        buildMenu();
        //Start the query
        showFirstPic();
        if (deckName.contains("DEFAULT") || deckName.contains("Favorites")) {
            restartAll(); // Because this decks are dynamic
        }
    }

    protected void onPause() { // We save the progress when the user leaves
        super.onPause();
        saveProgress();
    }

    public boolean loadRecent() { // This loads all recently learned sets
        SharedPreferences sharedPrefs = PreferenceManager.getDefaultSharedPreferences(this);
        Gson gson = new Gson();
        String json = sharedPrefs.getString("query_recent4", null);
        String json2 = sharedPrefs.getString("query_recent_names", null);
        Type type = new TypeToken<ArrayList<String>>() {
        }.getType();
        ArrayList<String> aL = gson.fromJson(json, type);
        ArrayList<String> aL2 = gson.fromJson(json2, type);
        if (aL == null) {
            return false;
        }
        recentlyLearned = aL;
        recentlyLearnedNames = aL2;
        return true;
    }

    public void saveRecent() { // This saves all recently learned sets
        SharedPreferences sharedPrefs = PreferenceManager.getDefaultSharedPreferences(this);
        SharedPreferences.Editor editor = sharedPrefs.edit();
        Gson gson = new Gson();
        String json = gson.toJson(recentlyLearned);
        String json2 = gson.toJson(recentlyLearnedNames);
        editor.putString("query_recent4", json);
        editor.putString("query_recent_names", json2);
        editor.commit();
    }

    public boolean loadProgress() { // This loads the progress of the current deck
        SharedPreferences sharedPrefs = PreferenceManager.getDefaultSharedPreferences(this);
        Gson gson = new Gson();
        String json = sharedPrefs.getString("query_list_" + deckName, null);
        Type type = new TypeToken<ArrayList<Card>>() {
        }.getType();
        ArrayList<Card> aL = gson.fromJson(json, type);
        int loadedIndex = sharedPrefs.getInt("query_index_" + deckName, -1);
        if (aL == null) {
            return false;
        }
        wrongGuessed = aL;
        indexCard = loadedIndex;
        return true;
    }

    public void saveProgress() { // This saves the progress of the current deck
        SharedPreferences sharedPrefs = PreferenceManager.getDefaultSharedPreferences(this);
        SharedPreferences.Editor editor = sharedPrefs.edit();
        Gson gson = new Gson();
        String json = gson.toJson(wrongGuessed);
        editor.putString("query_list_" + deckName, json);
        editor.putInt("query_index_" + deckName, indexCard);
        editor.commit();
    }

    public boolean onCreateOptionsMenu(Menu menu) {
        // Inflate the menu; this adds items to the action bar if it is present.
        getMenuInflater().inflate(R.menu.query, menu);
        return true;
    }

    public void shuffleWrongs() { // This shuffles the wrongGuessed-Arraylist
        Collections.shuffle(wrongGuessed, new Random(System.nanoTime()));
    }

    public void showPic(int MultiID) { // This method loads an cardimage into imgv with a given MultiverseID.
        Picasso.with(this)
                .load(getString(R.string.image_link_1) + MultiID +  getString(R.string.image_link_2)) // This tries to load an image from a link.
                .placeholder(R.drawable.loading_image)  // We want to show a image while its loading. We load our image from the "/res/drawable" folder
                .error(R.drawable.image_not_found) // If it fails to load image we show an error-image.
                .into(imgv); // This places the image into our ImageView.
    }

    public void showFirstPic() { // We need to call this, if we start with the first item
        updateScore(); // This will update the shown score
        showHiderInstant(); // This will instantly hide a part of the card
        firstGuess = true; // The user didn't guess yet, so it's his first guess
        showPic(wrongGuessed.get(indexCard).getMultiverseid()); // We show the current picture
        hiding.bringToFront(); // We want the hider in the front
        imgCorr.bringToFront(); // And imgCorr aswell, so the users sees these
        if (Mode == 1) {
            updateChoices(); // If the users uses mode one, we need to update the text of the buttons
        }
    }

    public void showNextPic() {
        updateScore(); // This will update the shown score
        showHider(); // We fade the hider in
        final Handler handler = new Handler();
        handler.postDelayed(new Runnable() {
            public void run() { // We add a little delay of 800 milliseconds, because of the animation
                firstGuess = true; // The user didn't guess yet, so it's his first guess
                showPic(wrongGuessed.get(indexCard).getMultiverseid()); // We show the current picture
                hiding.bringToFront(); // We want the hider in the front
                imgCorr.bringToFront(); // And imgCorr aswell, so the users sees these
                skipped = false; // The user didn't skip the current card
            }
        }, 800);
        if (Mode == 1) {
            updateChoices(); // If the users uses mode one, we need to update the text of the buttons
        }
    }

    public void checkAnswer(String txt) { // This method checks the answer
        if (txt.replaceAll("\\s+", "").equalsIgnoreCase(wrongGuessed.get(indexCard).getName().replaceAll("\\s+", ""))) {
            if (firstGuess) {
                wrongGuessed.remove(indexCard);//if he guessed it, we remove it.
            }
            else {
                indexCard++; // else we continue with the next card
            }
            if (indexCard == wrongGuessed.size()) { //If this true he's through the set
                final Handler handler = new Handler();
                handler.postDelayed(new Runnable() { // Add a delay of 1 second
                    public void run() {
                        setDone();
                    }
                }, 1000);
            } else {
                if (!skipped) {
                    imgCorr.setImageResource(R.drawable.correct_answer); // If the user didn't skip we show the "correct"-symbol
                    showImgCorr();
                }
                final Handler handler = new Handler();
                handler.postDelayed(new Runnable() { // Add a delay of 800 milliseconds
                    public void run() {
                        if (!skipped) {
                            hideImgCorr(); // We hide the symbol again
                        }
                        showNextPic(); // And show the next card
                    }
                }, 800);
            }
        } else {
            wrongAnswer(); // If the user didn't guess correctly, we call wrongAnswer()
        }
    }

    public void skip() { // Skips the card with an animation
        if (!skipped) {
            skipped = true; // The user skipped we set skipped to true
            wrongAnswer(); // The user didn't guess correctly
            final Handler handler = new Handler();
            handler.postDelayed(new Runnable() {
                public void run() {
                    checkAnswer(wrongGuessed.get(indexCard).getName()); // after a delay of 600 milliseconds we simulate a correct answer.
                }
            }, 600);
        }
    }

    public void wrongAnswer() {
        firstGuess = false; // The user didn't guess it on the first time
        imgCorr.setImageResource(R.drawable.wrong_answer); // We want to show the "Wrong"-image
        showImgCorr(); // We show the image
        hideHider(); // We show the correct answer
        final Handler handler = new Handler();
        handler.postDelayed(new Runnable() {
            public void run() {
                hideImgCorr(); // We hide the image after an delay of 1 second
            }
        }, 1000);
    }

    public void setDone() { // If the set is done, we show the endscreen and reshuffle the wrongGuessed-arraylist
        buildEndScreen();
        shuffleWrongs();
    }

    public void hideHider() { // Shows the name of the card fadingly
        hiding.animate().alpha(0).setDuration(600).setInterpolator(new DecelerateInterpolator()).withEndAction(new Runnable() {
            public void run() {
                hiding.animate().alpha(0).setDuration(1000).setInterpolator(new AccelerateInterpolator()).start();
            }
        }).start();
    }

    public void showHider() { // Hides the name of the card fadingly
        hiding.animate().alpha(1).setDuration(600).setInterpolator(new DecelerateInterpolator()).withEndAction(new Runnable() {
            public void run() {
                hiding.animate().alpha(1).setDuration(100).setInterpolator(new AccelerateInterpolator()).start();
            }
        }).start();
    }

    public void showHiderInstant() { // Hides the name of the card instantly
        hiding.animate().alpha(1).setDuration(10).setInterpolator(new DecelerateInterpolator()).withEndAction(new Runnable() {
            public void run() {
                hiding.animate().alpha(1).setDuration(100).setInterpolator(new AccelerateInterpolator()).start();
            }
        }).start();
    }

    public void hideImgCorr() {
        Animation myFadeInAnimation = AnimationUtils.loadAnimation(this, R.anim.fadeout);
        imgCorr.startAnimation(myFadeInAnimation); //Set animation to your ImageView
    }

    public void showImgCorr() {
        Animation myFadeInAnimation = AnimationUtils.loadAnimation(this, R.anim.fadein);
        imgCorr.startAnimation(myFadeInAnimation); //Set animation to your ImageView
    }

    public void buildMenu() { // This method simply build the UI
        int scrWidth = getWindowManager().getDefaultDisplay().getWidth(); // Get the width of the screen
        int scrHeight = getWindowManager().getDefaultDisplay().getHeight(); // Get the height of the screen
        RelativeLayout lyt = (RelativeLayout) findViewById(R.id.query_absolute); // Get the View of the XML
        RelativeLayout.LayoutParams params; // The parameters we want to add our views
        lyt.removeAllViews(); //Clear the Board

        imgv = new ImageView(this); // Create new Imageview
        params = new RelativeLayout.LayoutParams(scrWidth /*Width*/, (int) (0.5 * scrHeight))/*Height*/;
        params.leftMargin = 0; // X-Position
        params.topMargin = (int) (0.02 * scrHeight); // Y-Position
        lyt.addView(imgv, params); // add it to the View

        imgCorr = new ImageView(this); // Create new Imageview
        hideImgCorr(); // Hide this ImageView
        params = new RelativeLayout.LayoutParams(scrWidth /*Width*/, (int) (0.5 * scrHeight))/*Height*/;
        params.leftMargin = 0; // X-Position
        params.topMargin = (int) (0.02 * scrHeight); // Y-Position
        lyt.addView(imgCorr, params); // add it to the View

        switch (Mode) {
            case 0:
                buildMode0(); // If we have Mode 0, we continue building with Mode 0
                break;
            case 1:
                buildMode1(); // else we build Mode 1
        }
    }

    public void buildMode0() { // This method builds the UI for Mode 0
        int scrWidth = getWindowManager().getDefaultDisplay().getWidth(); // Get the width of the screen
        int scrHeight = getWindowManager().getDefaultDisplay().getHeight();  // Get the height of the screen
        RelativeLayout lyt = (RelativeLayout) findViewById(R.id.query_absolute); // Get the View of the XML
        RelativeLayout.LayoutParams params; // The parameters we want to add our views

        params = new RelativeLayout.LayoutParams((int) (0.55 * scrWidth) /*Width*/, (int) (0.03 * scrHeight)/*Height*/);
        params.leftMargin = (scrWidth / 2 - (int) (0.55 * scrWidth) / 2); // X-Position
        params.topMargin = (int) (0.045 * scrHeight); // Y-Position
        lyt.addView(hiding, params); // We add the hider

        // Add EditText like Imageview
        final EditText inputtxt = new EditText(this);
        inputtxt.setGravity(Gravity.CENTER);
        inputtxt.setHint(R.string.query_mode0_hint);
        params = new RelativeLayout.LayoutParams((int) (0.75 * scrWidth) /*Width*/, (int) (0.1 * scrHeight)/*Height*/);
        params.leftMargin = (int) (0.125 * scrWidth);
        params.topMargin = (int) (0.55 * scrHeight);
        lyt.addView(inputtxt, params);
        // Add a Listener to it (so the User can simply press ENTER on the keyboard)
        inputtxt.setOnKeyListener(new View.OnKeyListener() {
            public boolean onKey(View v, int keyCode, KeyEvent event) {
                if (event.getAction() == KeyEvent.ACTION_DOWN) {
                    switch (keyCode) {
                        case KeyEvent.KEYCODE_DPAD_CENTER:
                        case KeyEvent.KEYCODE_ENTER:
                            checkAnswer(inputtxt.getText().toString());
                            inputtxt.setText("");
                            return true;
                        default:
                            break;
                    }
                }
                return false;
            }
        });

        // add answer button
        Button answer = new Button(this);
        answer.setText("Answer");
        answer.setTextColor(Color.WHITE);
        answer.getBackground().setColorFilter(getResources().getColor(R.color.colorAccent), PorterDuff.Mode.MULTIPLY);
        params = new RelativeLayout.LayoutParams((int) (0.25 * scrWidth) /*Width*/, (int) (0.1 * scrHeight)/*Height*/);
        params.leftMargin = (scrWidth / 2) - (int) (0.25 * scrWidth);
        params.topMargin = (int) (0.50 * scrHeight) + (int) (0.15 * scrHeight);
        lyt.addView(answer, params);
        answer.setOnClickListener(new View.OnClickListener() {
            public void onClick(View view) {
                checkAnswer(inputtxt.getText().toString());
                inputtxt.setText("");
            }
        });

        // Add skip button
        Button skip = new Button(this);
        skip.setText("Skip");
        skip.setTextColor(Color.WHITE);
        skip.getBackground().setColorFilter(getResources().getColor(R.color.colorPrimary), PorterDuff.Mode.MULTIPLY);
        params = new RelativeLayout.LayoutParams((int) (0.25 * scrWidth) /*Width*/, (int) (0.1 * scrHeight)/*Height*/);
        params.leftMargin = (scrWidth / 2);
        params.topMargin = (int) (0.50 * scrHeight) + (int) (0.15 * scrHeight);
        lyt.addView(skip, params);
        skip.setOnClickListener(new View.OnClickListener() {
            public void onClick(View view) {
                skip();
            }
        });

        // show the score
        score = new TextView(this); // Create new Textview
        score.setGravity(Gravity.CENTER);
        score.setTextSize(36);
        params = new RelativeLayout.LayoutParams(scrWidth /*Width*/, (int) (0.1 * scrHeight)/*Height*/);
        params.leftMargin = 0; // X-Position
        params.topMargin = (int) (0.78 * scrHeight); // Y-Position
        lyt.addView(score, params); // add it to the View
    }

    public void buildMode1() { // This method builds the UI for Mode 1
        int scrWidth = getWindowManager().getDefaultDisplay().getWidth(); // Get the width of the screen
        int scrHeight = getWindowManager().getDefaultDisplay().getHeight(); // Get the height of the screen
        RelativeLayout lyt = (RelativeLayout) findViewById(R.id.query_absolute); // Get the View of the XML
        RelativeLayout.LayoutParams params; // The parameters we want to add our views

        params = new RelativeLayout.LayoutParams((int) (0.55 * scrWidth)/*Width*/, (int) (0.16 * scrHeight)/*Height*/);
        params.leftMargin = (scrWidth / 2 - (int) (0.55 * scrWidth) / 2); // X-Position
        params.topMargin = (int) (0.32 * scrHeight); // Y-Position
        lyt.addView(hiding, params); // Add the hider

        // Add all four buttons
        Button choice0 = new Button(this);
        choice0.setText("choice0");
        choice0.setTextSize(8);
        choice0.setTextColor(Color.WHITE);
        choice0.getBackground().setColorFilter(getResources().getColor(R.color.colorAccent), PorterDuff.Mode.MULTIPLY);
        params = new RelativeLayout.LayoutParams((int) (0.48 * scrWidth)/*Width*/, (int) (0.19 * scrHeight)/*Height*/);
        params.leftMargin = (int) (0.02 * scrWidth);
        params.topMargin = (int) (0.53 * scrHeight);
        lyt.addView(choice0, params);
        choice0.setOnClickListener(new View.OnClickListener() {
            public void onClick(View view) {
                onClickChoice(0);
            }
        });

        Button choice1 = new Button(this);
        choice1.setText("choice1");
        choice1.setTextSize(8);
        choice1.setTextColor(Color.WHITE);
        choice1.getBackground().setColorFilter(getResources().getColor(R.color.colorPrimary), PorterDuff.Mode.MULTIPLY);
        params = new RelativeLayout.LayoutParams((int) (0.48 * scrWidth)/*Width*/, (int) (0.19 * scrHeight)/*Height*/);
        params.leftMargin = (int) (0.50 * scrWidth);
        params.topMargin = (int) (0.53 * scrHeight);
        lyt.addView(choice1, params);
        choice1.setOnClickListener(new View.OnClickListener() {
            public void onClick(View view) {
                onClickChoice(1);
            }
        });

        Button choice2 = new Button(this);
        choice2.setText("choice2");
        choice2.setTextSize(8);
        choice2.setTextColor(Color.WHITE);
        choice2.getBackground().setColorFilter(getResources().getColor(R.color.colorPrimary), PorterDuff.Mode.MULTIPLY);
        params = new RelativeLayout.LayoutParams((int) (0.48 * scrWidth)/*Width*/, (int) (0.19 * scrHeight)/*Height*/);
        params.leftMargin = (int) (0.02 * scrWidth);
        params.topMargin = (int) (0.71 * scrHeight);
        lyt.addView(choice2, params);
        choice2.setOnClickListener(new View.OnClickListener() {
            public void onClick(View view) {
                onClickChoice(2);
            }
        });

        Button choice3 = new Button(this);
        choice3.setText("choice3");
        choice3.setTextSize(8);
        choice3.setTextColor(Color.WHITE);
        choice3.getBackground().setColorFilter(getResources().getColor(R.color.colorAccent), PorterDuff.Mode.MULTIPLY);
        params = new RelativeLayout.LayoutParams((int) (0.48 * scrWidth)/*Width*/, (int) (0.19 * scrHeight)/*Height*/);
        params.leftMargin = (int) (0.50 * scrWidth);
        params.topMargin = (int) (0.71 * scrHeight);
        lyt.addView(choice3, params);
        choice3.setOnClickListener(new View.OnClickListener() {
            public void onClick(View view) {
                onClickChoice(3);
            }
        });

        // Add the score
        score = new TextView(this); // Create new Textview
        score.setGravity(Gravity.CENTER);
        score.setTextSize(0);
        params = new RelativeLayout.LayoutParams(scrWidth /*Width*/, (int) (0.1 * scrHeight))/*Height*/;
        params.leftMargin = 0; // X-Position
        params.topMargin = (int) (0.78 * scrHeight); // Y-Position
        lyt.addView(score, params); // add it to the View

        choices = new ArrayList<>(); // Fill the arraylist with the buttons
        choices.add(choice0);
        choices.add(choice1);
        choices.add(choice2);
        choices.add(choice3);
    }

    public void onClickChoice(int nr) {
        if (choices.get(nr).getText() == wrongGuessed.get(indexCard).getText()) {
            if (firstGuess) {
                wrongGuessed.remove(indexCard);//if he guessed it, we remove it.
            }
            else {
                indexCard++; // else we continue with the next card
            }
            if (indexCard == wrongGuessed.size()) { //If this true he's through the set
                final Handler handler = new Handler();
                handler.postDelayed(new Runnable() { // 1 second delay
                    public void run() {
                        setDone(); // finish query
                    }
                }, 1000);
            } else {
                if (!skipped) {
                    imgCorr.setImageResource(R.drawable.correct_answer); // set "correct"-image if the user guessed it right
                    showImgCorr(); // show image
                }
                final Handler handler = new Handler();
                handler.postDelayed(new Runnable() { // 800 milliseconds delay
                    public void run() {
                        if (!skipped) {
                            hideImgCorr(); // hide image
                        }
                        showNextPic(); // continue query
                    }
                }, 800);
            }
        } else {
            wrongAnswer(); // If the user guessed it wrong, we call wrongAnswer()
        }
    }

    public void updateChoices() { // This sets the text of one button to the correct answer and the other ones to texts of random cards
        int rightOne = (int) (Math.random() * 4);
        for (int i = 0; i < choices.size(); i++) {
            if (i == rightOne) {
                choices.get(i).setText(wrongGuessed.get(indexCard).getText());
            } else {
                choices.get(i).setText(set.get((int) (Math.random() * set.size())).getText());
            }
        }

        for (int i = 0; i < choices.size() - 1; i++) {
            if (choices.get(i).getText() == choices.get(i + 1).getText()) {
                choices.get(i + 1).setText(set.get((int) (Math.random() * set.size())).getText());
            }
        }
    }

    public void updateScore() { // This updates the score text
        score.setText((set.size() - wrongGuessed.size()) + " / " + indexCard + " / " + (wrongGuessed.size() - indexCard));
    }

    public void buildEndScreen() { // This builds the end UI with the score and two buttons to restart.
        int scrWidth = getWindowManager().getDefaultDisplay().getWidth(); // Get screen-width
        int scrHeight = getWindowManager().getDefaultDisplay().getHeight(); // Get screen-height
        RelativeLayout lyt = (RelativeLayout) findViewById(R.id.query_absolute); // Get the View of the XML
        lyt.removeAllViews(); //Clear the board
        RelativeLayout.LayoutParams params; // the parameters we need for our Views

        // Show the amount of right guessed cards
        TextView rights = new TextView(this);
        rights.setText("Right: ");
        rights.setTextSize(36);
        rights.setTextColor(getResources().getColor(R.color.colorPrimary));
        params = new RelativeLayout.LayoutParams(scrWidth /*Width*/, (int) (0.1 * scrHeight))/*Height*/;
        params.leftMargin = (int) (0.1 * scrHeight); // X-Position
        params.topMargin = (int) (0.05 * scrHeight); // Y-Position
        lyt.addView(rights, params); // add it to the View

        TextView rights2 = new TextView(this);
        rights2.setText("" + (set.size() - wrongGuessed.size()));
        rights2.setTextSize(36);
        rights2.setTextColor(getResources().getColor(R.color.colorPrimary));
        params = new RelativeLayout.LayoutParams(scrWidth /*Width*/, (int) (0.1 * scrHeight))/*Height*/;
        params.leftMargin = (int) (0.4 * scrHeight); // X-Position
        params.topMargin = (int) (0.05 * scrHeight); // Y-Position
        lyt.addView(rights2, params); // add it to the View

        // Show the amount of wrong guessed cards
        TextView wrongs = new TextView(this);
        wrongs.setText("Wrong: ");
        wrongs.setTextSize(36);
        wrongs.setTextColor(getResources().getColor(R.color.colorAccent));
        params = new RelativeLayout.LayoutParams(scrWidth /*Width*/, (int) (0.1 * scrHeight))/*Height*/;
        params.leftMargin = (int) (0.1 * scrHeight); // X-Position
        params.topMargin = (int) (0.05 * scrHeight) + (int) (0.1 * scrHeight); // Y-Position
        lyt.addView(wrongs, params); // add it to the View

        TextView wrongs2 = new TextView(this);
        wrongs2.setText("" + (wrongGuessed.size()));
        wrongs2.setTextSize(36);
        wrongs2.setTextColor(getResources().getColor(R.color.colorAccent));
        params = new RelativeLayout.LayoutParams(scrWidth /*Width*/, (int) (0.1 * scrHeight))/*Height*/;
        params.leftMargin = (int) (0.4 * scrHeight); // X-Position
        params.topMargin = (int) (0.05 * scrHeight) + (int) (0.1 * scrHeight); // Y-Position
        lyt.addView(wrongs2, params); // add it to the View

        // Show the amount of total cards
        TextView total = new TextView(this);
        total.setText("Total: ");
        total.setTextSize(36);
        total.setTextColor(Color.BLACK);
        params = new RelativeLayout.LayoutParams(scrWidth /*Width*/, (int) (0.09 * scrHeight))/*Height*/;
        params.leftMargin = (int) (0.1 * scrHeight); // X-Position
        params.topMargin = (int) (0.05 * scrHeight) + (int) (0.1 * scrHeight) + (int) (0.1 * scrHeight); // Y-Position
        lyt.addView(total, params); // add it to the View

        TextView total2 = new TextView(this);
        total2.setText("" + (set.size()));
        total2.setTextSize(36);
        total2.setTextColor(Color.BLACK);
        params = new RelativeLayout.LayoutParams(scrWidth /*Width*/, (int) (0.09 * scrHeight))/*Height*/;
        params.leftMargin = (int) (0.4 * scrHeight); // X-Position
        params.topMargin = (int) (0.05 * scrHeight) + (int) (0.1 * scrHeight) + (int) (0.1 * scrHeight); // Y-Position
        lyt.addView(total2, params); // add it to the View

        // Show "repeat wrong guessed"-button if there are cards left
        if (wrongGuessed.size() > 0) {
            Button repWrong = new Button(this);
            repWrong.setText("Repeat wrong guessed");
            repWrong.setTextColor(Color.WHITE);
            repWrong.getBackground().setColorFilter(getResources().getColor(R.color.colorAccent), PorterDuff.Mode.MULTIPLY);
            params = new RelativeLayout.LayoutParams((int) (0.90 * scrWidth)/*Width*/, (int) (0.1 * scrHeight)/*Height*/);
            params.leftMargin = (int) (0.05 * scrWidth);
            params.topMargin = (int) (0.4 * scrHeight) + (int) (0.1 * scrHeight) + (int) (0.1 * scrHeight) + (int) (0.1 * scrHeight);
            lyt.addView(repWrong, params);
            repWrong.setOnClickListener(new View.OnClickListener() {
                public void onClick(View view) {
                    buildMenu();
                    indexCard = 0;
                    showFirstPic();
                }
            });
        }

        // Show "Repeat all"-button
        Button repAll = new Button(this);
        repAll.setText("Repeat all");
        repAll.setTextColor(Color.WHITE);
        repAll.getBackground().setColorFilter(getResources().getColor(R.color.colorPrimary), PorterDuff.Mode.MULTIPLY);
        params = new RelativeLayout.LayoutParams((int) (0.90 * scrWidth)/*Width*/, (int) (0.1 * scrHeight)/*Height*/);
        params.leftMargin = (int) (0.05 * scrWidth);
        params.topMargin = (int) (0.5 * scrHeight) + (int) (0.1 * scrHeight) + (int) (0.1 * scrHeight) + (int) (0.1 * scrHeight);
        lyt.addView(repAll, params);
        repAll.setOnClickListener(new View.OnClickListener() {
            public void onClick(View view) {
                restartAll();
            }
        });

    }

    public void restartAll() { // This restarts all. A fresh start
        wrongGuessed = (ArrayList) set.clone();
        if (!queryLand) {
            removeLands();
        }
        shuffleWrongs();
        buildMenu();
        indexCard = 0;
        showFirstPic();
    }

    public void removeLands() { // This removes all Lands of wrongGuessed
        ArrayList<Card> remove = new ArrayList<>();
        for (Card c : wrongGuessed) {
            if (c.getType().contains("Land")) {
                remove.add(c);
            }
        }
        for (Card c : remove) {
            wrongGuessed.remove(c);
        }

    }

    public boolean onOptionsItemSelected(MenuItem item) {
        int id = item.getItemId();
        switch (id) {
            case android.R.id.home:
                onBackPressed(); // If the user presses the "back"-button we close the activity
                break;
            case R.id.restart_all:
                restartAll(); // restart the query if the user presses "restart"
                break;
            case R.id.query_lands: // removes/adds lands
                queryLand = !queryLand;
                item.setChecked(queryLand);
                if (queryLand) {
                    restartAll();
                } else {
                    removeLands();
                    updateScore();
                }
                break;
            case R.id.query_revers: // Change modes
                if (set.size() < 4) {
                    break;
                }
                if (Mode == 1) {
                    Mode = 0;
                } else {
                    Mode = 1;
                }
                restartAll();
                break;
        }
        return true;
    }

    public void onBackPressed() {
        finish(); // This closes our Activity
        overridePendingTransition(R.anim.slide_in_right, R.anim.slide_out_right); // We want to close it with an fancy animation.
    }
}
\end{lstlisting}
\newpage
\subsection{FavoritesActivity.java}
\begin{lstlisting}
package m2b.magic2brain.com;

import android.content.Context;
import android.content.Intent;
import android.os.Bundle;
import android.support.design.widget.FloatingActionButton;
import android.support.design.widget.Snackbar;
import android.support.v7.app.AppCompatActivity;
import android.view.MenuItem;
import android.view.View;
import android.widget.AdapterView;
import android.widget.ArrayAdapter;
import android.widget.ListView;
import java.util.ArrayList;
import m2b.magic2brain.com.magic2brain.R;

/*
This class shows all Favorites in a list
*/

public class FavoritesActivity extends AppCompatActivity {

    protected void onCreate(Bundle savedInstanceState) {
        overridePendingTransition(R.anim.slide_in_left, R.anim.slide_out_left); // This adds an fancy slide animation, when this activity starts.
        super.onCreate(savedInstanceState); // This does some intern stuff. We don't need to worry about that. It's just needed.
        setTitle(getString(R.string.FavoritesActivity_title)); // We set a title to our View. We defined the title in "/res/values/strings.xml". We just load it from there.
        setContentView(R.layout.activity_favorites); // This adds an View to our Activity. We defined at "/res/layout/activity_favorites.xml" how our activity should look like.
        getSupportActionBar().setDisplayHomeAsUpEnabled(true); // With this line we add an "back"-Button to the Toolbar. If we press it it calls onOptionsItemSelected();
        buildMenu(); // This simply builds the menu
    }

    protected void onResume() { // If we get back to this activity, we build the menu again, because its possible that the user removed a card.
        super.onResume();
        buildMenu();
    }

    private void buildMenu() {
        final Context currentContext = this; // This doesn't actually do anything, but it's needed if we want to refer to "this" from an inner class.

        final ArrayList<Card> alist_favs = Favorites.favorites_mvid; // This loads all the favorites
        final Card[] cards = new Card[alist_favs.size()]; // We want to turn it into a card-array, so its finite
        final String[] favs = new String[alist_favs.size()]; // For the list we need just the names
        for (int i = 0; i < alist_favs.size(); i++) {
            favs[i] = alist_favs.get(i).getName(); // We add all names into the string-array
            cards[i] = alist_favs.get(i); // We add all cards into the card-array
        }

        final ArrayAdapter adapter = new ArrayAdapter(this, android.R.layout.simple_list_item_1, favs); // This is just a helper-class. It transforms our String-Array into an clickable List.
        final ListView lv = (ListView) findViewById(R.id.favList); // We want to add our list to the ListView. So we get the ListView from the View
        lv.setAdapter(adapter); // We add our list into it.

        lv.setOnItemClickListener(new AdapterView.OnItemClickListener() { // This performs an action when we click on an item from the list.
            public void onItemClick(AdapterView<?> parent, View view, int position, long id) {
                // The following code starts CardBrowserActivity and passes the card of the item we clicked.
                Intent intent = new Intent(currentContext, CardBrowserActivity.class);
                intent.putExtra("currentCard", cards[position]);
                startActivity(intent);
            }
        });


        FloatingActionButton fam = (FloatingActionButton) findViewById(R.id.fab_addlearn); // This gets the "start"-button from the view
        fam.setOnClickListener(new View.OnClickListener() { // when we press the button an action should be performed
            public void onClick(View view) {
                // The following code checks the amount of the favorites. If it's zero, the user gets a notification which says, that there are no cards to learn.
                // If there are cards in favorites, it constructs a deck-object and fills it with all the cards. After that it starts the query with that deck.
                if (alist_favs.size() > 0) {
                    Intent intent = new Intent(currentContext, QueryActivity.class);
                    Deck d = new Deck();
                    d.setCode("FAVS");
                    d.setName("Favorites");
                    d.setSet(alist_favs);
                    intent.putExtra("Set", d);
                    startActivity(intent);
                } else {
                    Snackbar.make(view, R.string.No_Favs_to_learn, Snackbar.LENGTH_LONG).setAction("Action", null).show();
                }
            }
        });

    }

    public boolean onOptionsItemSelected(MenuItem item) {
        switch (item.getItemId()) {
            // Respond to the action bar's Up/Home button
            case android.R.id.home:
                onBackPressed();
        }
        return true;
    }

    public void onBackPressed() {
        finish();  // This closes our Activity
        overridePendingTransition(R.anim.slide_in_right, R.anim.slide_out_right); // We want to close it with an fancy animation.
    }
}
\end{lstlisting}
\newpage
\subsection{LastSeenActivity.java}
\begin{lstlisting}
package m2b.magic2brain.com;

import android.content.Context;
import android.content.Intent;
import android.content.SharedPreferences;
import android.os.Bundle;
import android.preference.PreferenceManager;
import android.support.v7.app.AppCompatActivity;
import android.view.MenuItem;
import android.view.View;
import android.widget.AdapterView;
import android.widget.AdapterView.OnItemClickListener;
import android.widget.ArrayAdapter;
import android.widget.ListView;
import com.google.gson.Gson;
import com.google.gson.reflect.TypeToken;
import java.lang.reflect.Type;
import java.util.ArrayList;
import m2b.magic2brain.com.magic2brain.R;

/*
This class should show all recently learned sets.
 */
public class LastSeenActivity extends AppCompatActivity {
    private ArrayList<String> recentlyLearned; // loadRecent() will load all deck-codes in this arraylist
    private ArrayList<String> recentlyLearnedNames; // loadRecent() will load all deck-names in this arraylist
    private String[] names; // this will contain all the names of the decks
    private String[] reclearn; // this will contain all the deck-codes of the decks

    protected void onCreate(Bundle savedInstanceState) {
        overridePendingTransition(R.anim.slide_in_left, R.anim.slide_out_left); // This adds an fancy slide animation, when this activity starts.
        super.onCreate(savedInstanceState); // This does some intern stuff. We don't need to worry about that. It's just needed.
        setContentView(R.layout.activity_last_seen); // This adds an View to our Activity. We defined at "/res/layout/activity_last_seen.xml" how our activity should look like.
        setTitle(getString(R.string.LastSeenActivity_title)); // We set a title to our View. We defined the title in "/res/values/strings.xml". We just load it from there.
        getSupportActionBar().setDisplayHomeAsUpEnabled(true); // With this line we add an "back"-Button to the Toolbar. If we press it it calls onOptionsItemSelected();
        final Context currentContext = this;  // This doesn't actually do anything, but it's needed if we want to refer to "this" from an inner class.

        if (!loadRecent()) { // if it fails to load all the decks, we simply replace recentlyLearned with an empty arraylist
            recentlyLearned = new ArrayList<>();
        }
        names = new String[recentlyLearned.size()]; // we initiate names with the size of recentlyLearned
        reclearn = new String[recentlyLearned.size()]; // we initiate reclearn with the size of recentlyLearned
        for (int i = 0; i < recentlyLearned.size(); i++) {
            reclearn[i] = recentlyLearned.get(i); // we fill reclearn with all the deck-codes
            names[i] = recentlyLearnedNames.get(i); // we fill names with all the names
        }

        final ArrayAdapter adapter = new ArrayAdapter(this, android.R.layout.simple_list_item_1, names); // This is just a helper-class. It transforms our String-Array into an clickable List.
        ListView lv = (ListView) findViewById(R.id.mListView); // We want to add our list to the ListView. So we get the ListView from the View
        lv.setAdapter(adapter); // We add our list into it.

        lv.setOnItemClickListener(new OnItemClickListener() { // This performs an action when we click on an item from the list.
            public void onItemClick(AdapterView<?> parent, View view, int position, long id) {
                // The following code starts DeckDisplayActivity and passes the Deck-Code and the Deck-Name of the item we clicked.
                String code = reclearn[position];
                String name = names[position];
                Intent intent = new Intent(currentContext, DeckDisplayActivity.class);
                intent.putExtra("code", code);
                intent.putExtra("name", name);
                startActivity(intent);
            }
        });

    }

    private boolean loadRecent() { // this function loads the recently learned deck from the memory. If it fails it returns false.
        SharedPreferences sharedPrefs = PreferenceManager.getDefaultSharedPreferences(this);
        Gson gson = new Gson();
        String json = sharedPrefs.getString("query_recent4", null);
        String json2 = sharedPrefs.getString("query_recent_names", null);
        Type type = new TypeToken<ArrayList<String>>() {
        }.getType();
        ArrayList<String> aL = gson.fromJson(json, type);
        ArrayList<String> aL2 = gson.fromJson(json2, type);
        if (aL == null) {
            return false;
        }
        recentlyLearned = aL;
        recentlyLearnedNames = aL2;
        return true;
    }

    public boolean onOptionsItemSelected(MenuItem item) {
        switch (item.getItemId()) {
            // Respond to the action bar's Up/Home button
            case android.R.id.home:
                onBackPressed();
        }
        return true;
    }

    public void onBackPressed() {
        finish(); // This closes our Activity
        overridePendingTransition(R.anim.slide_in_right, R.anim.slide_out_right); // We want to close it with an fancy animation.
    }
}
\end{lstlisting}
\newpage
\subsection{DeckAssetLoader.java}
\begin{lstlisting}
package m2b.magic2brain.com;

import android.content.Context;
import org.json.JSONArray;
import org.json.JSONObject;
import java.io.BufferedReader;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.io.Reader;
import java.io.StringWriter;
import java.io.Writer;

/*
This is an helper-class. All functions all static so we don't need to create an object. This class basicly loads all informations of an deck or card from an JSON-file from our assets-folder.
There's alot of low-level actions going on there.
*/
public class DeckAssetLoader {

    public DeckAssetLoader() {}

    public static Card[] getDeck(String deckname, Context context) {
        Card[] c = null;
        try {
            InputStream is = context.getAssets().open(deckname);
            Writer writer = new StringWriter();
            char[] buffer = new char[1024];
            Reader reader = new BufferedReader(new InputStreamReader(is, "UTF-8"));
            int n;
            while ((n = reader.read(buffer)) != -1) {
                writer.write(buffer, 0, n);
            }
            is.close();
            String jsonString= writer.toString();
            c = parseCardJSON(jsonString);
        } catch (Exception e){}
        return c;
    }

    public static Deck[] getDeckList(Context context) {
        Deck[] darray = null;
                try {
                    InputStream is = context.getAssets().open("SetList.json");
                    Writer writer = new StringWriter();
                    char[] buffer = new char[1024];
                    try {
                        Reader reader = new BufferedReader(new InputStreamReader(is, "UTF-8"));
                        int n;
                        while ((n = reader.read(buffer)) != -1) {
                            writer.write(buffer, 0, n);
                        }
                    } finally {
                        is.close();
                    }
                    String jsonString = writer.toString();
                    darray = parseDeckJSON(jsonString);
                } catch (Exception e){}
        return darray;
    }

    private static Deck[] parseDeckJSON(String json) {
        Deck[] list = null;
        try {
            JSONArray file = new JSONArray(json);

            list = new Deck[file.length()];

            for (int i = 0; i < file.length(); i++) {
                JSONObject card = file.getJSONObject(i);
                Deck c = new Deck();

                String deck_name = card.getString("name");
                String deck_code = card.getString("code");
                String deck_releaseDate = card.getString("releaseDate");

                c.setName(deck_name);
                c.setCode(deck_code);
                c.setReleaseDate(deck_releaseDate);

                list[i] = c;
            }
        } catch (Exception e){}
        return list;
    }

    private static Card[] parseCardJSON(String json)  {
        Card[] carray = null;
        try {
            JSONObject deck = new JSONObject(json);
            JSONArray cards = deck.getJSONArray("cards");
            carray = new Card[cards.length()];

            for (int i = 0; i < cards.length(); i++) {
                JSONObject card = cards.getJSONObject(i);
                Card c = new Card();
                String mvid_as_string = card.getString("multiverseid");
                String card_name = card.getString("name");

                String card_flavor = "";
                String card_text = "";
                String card_type = "";
                String card_cost = "";

                if (card.has("flavor")) {
                    card_flavor = card.getString("flavor");
                }

                if (card.has("text")) {
                    card_text = card.getString("text");
                }

                if (card.has("type")) {
                    card_type = card.getString("type");
                }
                if (card.has("manaCost")) {
                    card_cost = card.getString("manaCost");
                }

                c.setName(card_name);
                c.setMultiverseid(Integer.parseInt(mvid_as_string));
                c.setText(card_text);
                c.setFlavor(card_flavor);
                c.setType(card_type);
                c.setManaCost(card_cost);

                carray[i] = c;
            }
        } catch (Exception e){}
        return carray;
    }
}
\end{lstlisting}
\newpage
\subsection{Card.java}
\begin{lstlisting}
package m2b.magic2brain.com;

import java.io.Serializable;

/*
This is a class to store Cards. It stores all crucial informations of a card and has the Getters and Setters for it. There are also three Constructors.
*/
public class Card implements Serializable {
    private int multiverseid;
    private String name;
    private String flavor;
    private String text;
    private String type;
    private String manacost;

    public Card(int multiverseid, String name) {
        setMultiverseid(multiverseid);
        setName(name);
        // We fill the undefined variables with something to avoid NullPointer-Errors.
        type = "UNKOWN";
        flavor = "UNKOWN";
        text = "UNKOWN";
        manacost = "NA";
    }

    public Card(String name, String flavor, String text, String type, String manacost) {
        this.type = type;
        this.name = name;
        this.flavor = flavor;
        this.text = text;
        this.manacost = manacost;
    }

    public Card() {}

    public int getMultiverseid() {
        return multiverseid;
    }

    public void setMultiverseid(int multiverseid) {
        this.multiverseid = multiverseid;
    }

    public String getName() {
        return this.name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public String getFlavor() {
        return this.flavor;
    }

    public void setFlavor(String flavor) {
        this.flavor = flavor;
    }

    public String getText() {
        return this.text;
    }

    public void setText(String text) {
        this.text = text;
    }

    public String getType() {
        return type;
    }

    public void setType(String type) {
        this.type = type;
    }

    public String getManaCost() {
        return manacost;
    }

    public void setManaCost(String type) {
        this.manacost = type;
    }
}
\end{lstlisting}
\newpage
\subsection{Deck.java}
\begin{lstlisting}
package m2b.magic2brain.com;

import java.io.Serializable;
import java.util.ArrayList;
import java.util.Arrays;

/*
This class stores a deck with all its informations. It has the Getters and Setters for the informations. There are also two Constructors.
 */
public class Deck implements Serializable /* We need to do this, so we can pass Decks with Intents */ {

    private ArrayList<Card> set;
    private String name;
    private String code;
    private String releaseDate;
    private String icon;

    public Deck() {
        set = new ArrayList<>();
    }

    public Deck(String name, String code, String release_date, String iconUri) {
        this.name = name;
        this.code = code;
        this.releaseDate = release_date;
        this.icon = iconUri;
        set = new ArrayList<>();
    }

    public String getIcon() {
        return icon;
    }

    public void setIcon(String icon) {
        this.icon = icon;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public String getCode() {
        return code;
    }

    public void setCode(String code) {
        this.code = code;
    }

    public String getReleaseDate() {
        return releaseDate;
    }

    public void setReleaseDate(String releaseDate) {
        this.releaseDate = releaseDate;
    }

    public int getSize() {
        return set.size();
    }

    public ArrayList<Card> getSet() {
        return set;
    }

    public void setSet(ArrayList<Card> al) {
        set = al;
    }

    public void setSet(Card[] c){set = new ArrayList<>(Arrays.asList(c));}
}
\end{lstlisting}
\newpage
\subsection{Favorites.java}
\begin{lstlisting}
package m2b.magic2brain.com;

import java.util.ArrayList;

/*
This is very simple class. It's just here to temporary store all favorites and pass them to any other class.
*/

public final class Favorites {
    public static ArrayList<Card> favorites_mvid;
    public static void init() {
        favorites_mvid = new ArrayList<>();
    }
}
\end{lstlisting}
\newpage
\subsection{RUtils.java}
\begin{lstlisting}
package m2b.magic2brain.com;

/*
This class is a helper-class. All functions are static so we don't need any objects.
 */
public class RUtils {

    public static String[] getListified(Card[] cards) { // This turns a Card-Array into a String-Array
        String[] list = new String[cards.length];
        for (int i = 0; i < cards.length; i++) {
            list[i] = cards[i].getName();
        }
        return list;
    }

    public static boolean isInteger(String s) {
        return isInteger(s, 10);
    }

    public static boolean isInteger(String s, int radix) {
        if (s.isEmpty()) return false;
        for (int i = 0; i < s.length(); i++) {
            if (i == 0 && s.charAt(i) == '-') {
                if (s.length() == 1) return false;
                else continue;
            }
            if (Character.digit(s.charAt(i), radix) < 0) return false;
        }
        return true;
    }
}
\end{lstlisting}